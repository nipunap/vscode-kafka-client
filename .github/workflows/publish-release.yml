name: Publish Release

on:
  push:
    branches:
      - main
    paths:
      - 'package.json'

concurrency:
  group: publish-release
  cancel-in-progress: false

# Security: Explicitly define minimal permissions at workflow level
permissions:
  actions: read       # Needed for wait-on-check
  checks: read        # Needed for wait-on-check
  contents: write     # Needed for creating releases
  deployments: none   # Prevent deployment manipulation
  issues: write       # Needed for creating issues on publish failure
  packages: none      # Prevent package manipulation
  pull-requests: read # Needed for waiting on checks
  repository-projects: none
  security-events: write  # Needed for dependency-review
  statuses: none

jobs:
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Wait for CI checks
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ github.sha }}
          check-regexp: '^(Build and Test|Lint Report|Status Check).*$'
          running-workflow-name: 'Wait for CI'  # Prevent self-waiting
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30
          allowed-conclusions: success

  version-check:
    name: Check Version Change
    runs-on: ubuntu-latest
    needs: wait-for-ci
    timeout-minutes: 5
    outputs:
      changed: ${{ steps.check.outputs.changed }}
      version: ${{ steps.check.outputs.version }}
      previous_version: ${{ steps.check.outputs.previous_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for tag comparison

      - name: Check if version changed
        id: check
        run: |
          set -e

          # Get current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"

          # Get last released version from git tags
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*.*.*" 2>/dev/null || echo "v0.0.0")
          PREVIOUS_VERSION=${LAST_TAG#v}
          echo "Previous version (from tags): $PREVIOUS_VERSION"

          # Validate semantic version format
          if ! npx --yes semver "$CURRENT_VERSION" >/dev/null 2>&1; then
            echo "‚ùå Invalid semantic version format: $CURRENT_VERSION"
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Check version increment (must be greater than previous)
          if [ "$PREVIOUS_VERSION" != "0.0.0" ]; then
            if ! npx --yes semver -r ">$PREVIOUS_VERSION" "$CURRENT_VERSION" >/dev/null 2>&1; then
              echo "‚ùå Version $CURRENT_VERSION must be greater than previous version $PREVIOUS_VERSION"
              echo "changed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

          # Check if this version already has a tag
          if git rev-parse "v$CURRENT_VERSION" >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è Version v$CURRENT_VERSION already tagged, skipping release"
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
            echo "‚úÖ Version changed: $PREVIOUS_VERSION ‚Üí $CURRENT_VERSION"
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è Version unchanged, skipping release"
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

  security:
    name: Security & Dependency Review
    runs-on: ubuntu-latest
    needs: version-check
    if: needs.version-check.outputs.changed == 'true'
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Security scan
        uses: github/super-linter@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BRANCH: main
          VALIDATE_ALL_CODEBASE: false
          VALIDATE_YAML: true
          VALIDATE_JSON: true
          VALIDATE_JAVASCRIPT_ES: true
          VALIDATE_TYPESCRIPT_ES: true
          # Only validate languages explicitly set to true above
          FILTER_REGEX_EXCLUDE: '.*node_modules.*'
      
      # Note: dependency-review-action removed - it's designed for PRs, not push events
      # Dependencies are reviewed in ci.yml during pull request phase

  build:
    name: Build & Package Extension
    runs-on: ubuntu-latest
    needs: [version-check, security]
    if: needs.version-check.outputs.changed == 'true'
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        timeout-minutes: 5
        run: npm ci

      - name: Install tools
        timeout-minutes: 2
        run: |
          npm install -g @vscode/vsce
          npm install -g semver

      - name: Compile TypeScript
        timeout-minutes: 5
        run: npm run compile

      - name: Package extension
        timeout-minutes: 5
        run: npm run package

      - name: Find and validate VSIX
        id: vsix
        run: |
          set -e

          # Find VSIX file (robust method)
          VSIX_FILE=$(find . -maxdepth 1 -name "*.vsix" -type f | head -n 1)

          if [ -z "$VSIX_FILE" ]; then
            echo "‚ùå No VSIX file found after packaging"
            exit 1
          fi

          # Check for multiple VSIX files
          VSIX_COUNT=$(find . -maxdepth 1 -name "*.vsix" -type f | wc -l)
          if [ "$VSIX_COUNT" -gt 1 ]; then
            echo "‚ö†Ô∏è Multiple VSIX files found ($VSIX_COUNT), using: $VSIX_FILE"
            find . -maxdepth 1 -name "*.vsix" -type f
          fi

          # Get file info
          FILE_SIZE=$(stat -f%z "$VSIX_FILE" 2>/dev/null || stat -c%s "$VSIX_FILE")
          FILE_SIZE_MB=$((FILE_SIZE / 1024 / 1024))
          echo "üì¶ VSIX package: $VSIX_FILE (${FILE_SIZE_MB}MB)"

          # Validate size (reasonable limits)
          if [ "$FILE_SIZE" -lt 1024 ]; then
            echo "‚ùå VSIX file too small (< 1KB), likely corrupted"
            exit 1
          fi

          if [ "$FILE_SIZE" -gt 104857600 ]; then
            echo "‚ùå VSIX file too large (> 100MB), exceeds marketplace limits"
            exit 1
          fi

          if [ "$FILE_SIZE_MB" -gt 50 ]; then
            echo "‚ö†Ô∏è VSIX file is large (${FILE_SIZE_MB}MB), consider optimization"
          fi

          # Validate VSIX structure
          echo "Validating VSIX contents..."
          if ! unzip -l "$VSIX_FILE" | grep -q "extension/package.json"; then
            echo "‚ùå Invalid VSIX: missing extension/package.json"
            exit 1
          fi

          if ! unzip -l "$VSIX_FILE" | grep -q "extension.vsixmanifest"; then
            echo "‚ùå Invalid VSIX: missing extension.vsixmanifest"
            exit 1
          fi

          # Extract and validate package.json version
          unzip -p "$VSIX_FILE" "extension/package.json" > /tmp/vsix-package.json
          VSIX_VERSION=$(node -p "require('/tmp/vsix-package.json').version")
          EXPECTED_VERSION="${{ needs.version-check.outputs.version }}"

          if [ "$VSIX_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "‚ùå Version mismatch: VSIX contains v$VSIX_VERSION but expected v$EXPECTED_VERSION"
            exit 1
          fi

          echo "‚úÖ VSIX validation passed"
          echo "vsix_file=$VSIX_FILE" >> $GITHUB_OUTPUT
          echo "vsix_size=$FILE_SIZE" >> $GITHUB_OUTPUT

      - name: Upload VSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: vscode-kafka-${{ needs.version-check.outputs.version }}.vsix
          path: '*.vsix'
          retention-days: 90
          if-no-files-found: error

  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [version-check, build]
    if: needs.version-check.outputs.changed == 'true'
    timeout-minutes: 10
    outputs:
      release_created: ${{ steps.create_release.outputs.release_created }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: vscode-kafka-${{ needs.version-check.outputs.version }}.vsix

      - name: Extract version-specific changelog
        id: extract_changelog
        run: |
          VERSION="${{ needs.version-check.outputs.version }}"

          if [ -f CHANGELOG.md ]; then
            echo "Extracting changelog for version $VERSION..."

            # Look for the version header and extract until the next version header
            awk "/^## \[$VERSION\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md > version_changelog.md

            if [ -s version_changelog.md ]; then
              echo "‚úÖ Found changelog section for v$VERSION"
              echo "has_changelog=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è No changelog section found for v$VERSION"
              echo "has_changelog=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è CHANGELOG.md not found"
            echo "has_changelog=false" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.version-check.outputs.version }}
          name: Release v${{ needs.version-check.outputs.version }}
          body_path: ${{ steps.extract_changelog.outputs.has_changelog == 'true' && 'version_changelog.md' || '' }}
          draft: false
          prerelease: false
          make_latest: true
          generate_release_notes: true
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Mark release created
        if: success()
        run: |
          echo "release_created=true" >> $GITHUB_OUTPUT
          echo "‚úÖ GitHub Release v${{ needs.version-check.outputs.version }} created successfully"

  publish-vscode:
    name: Publish to VS Code Marketplace
    runs-on: ubuntu-latest
    needs: [version-check, release]
    if: needs.version-check.outputs.changed == 'true'
    timeout-minutes: 15

    steps:
      - name: Download VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: vscode-kafka-${{ needs.version-check.outputs.version }}.vsix

      - name: Check Azure token availability
        id: check_token
        env:
          AZURE_TOKEN: ${{ secrets.AZURE_TOKEN }}
        run: |
          if [ -n "$AZURE_TOKEN" ]; then
            echo "has_token=true" >> $GITHUB_OUTPUT
          else
            echo "has_token=false" >> $GITHUB_OUTPUT
          fi

      - name: Install vsce
        if: steps.check_token.outputs.has_token == 'true'
        run: npm install -g @vscode/vsce

      - name: Publish to VS Code Marketplace
        id: publish
        if: steps.check_token.outputs.has_token == 'true'
        timeout-minutes: 10
        run: |
          set -e
          VSIX_FILE=$(find . -maxdepth 1 -name "*.vsix" -type f | head -n 1)

          if [ -z "$VSIX_FILE" ]; then
            echo "‚ùå VSIX file not found"
            exit 1
          fi

          echo "Publishing $VSIX_FILE to VS Code Marketplace..."
          vsce publish --packagePath "$VSIX_FILE" --pat "$VSCE_PAT"
          echo "‚úÖ Published to VS Code Marketplace"
        env:
          VSCE_PAT: ${{ secrets.AZURE_TOKEN }}
        continue-on-error: true

      - name: Report success
        if: steps.check_token.outputs.has_token == 'true' && steps.publish.outcome == 'success'
        run: |
          echo "‚úÖ Successfully published v${{ needs.version-check.outputs.version }} to VS Code Marketplace"

      - name: Report marketplace publish failure
        if: steps.check_token.outputs.has_token == 'true' && steps.publish.outcome == 'failure'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Failed to publish v${{ needs.version-check.outputs.version }} to VS Code Marketplace',
              body: [
                '## Marketplace Publish Failed',
                '',
                '**Version:** v${{ needs.version-check.outputs.version }}',
                '**Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}',
                '',
                'The automated marketplace publish step failed. This may require manual intervention.',
                '',
                '### Next Steps:',
                '1. Check the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details',
                '2. Verify AZURE_TOKEN secret is valid and has proper permissions',
                '3. Download the VSIX from [workflow artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
                '4. Publish manually: `vsce publish --packagePath <vsix-file>`',
                '5. Close this issue once resolved',
                '',
                '**Note:** The GitHub Release and git tag were created successfully.'
              ].join('\n'),
              labels: ['release', 'automation', 'marketplace', 'bug']
            });

      - name: Report token missing
        if: steps.check_token.outputs.has_token == 'false'
        run: |
          echo "‚ö†Ô∏è AZURE_TOKEN not configured, skipping VS Code Marketplace publish"
          echo "To enable automatic publishing, add AZURE_TOKEN secret to repository settings"

  publish-openvsx:
    name: Publish to Open VSX Registry
    runs-on: ubuntu-latest
    needs: [version-check, release]
    if: needs.version-check.outputs.changed == 'true'
    timeout-minutes: 15

    steps:
      - name: Download VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: vscode-kafka-${{ needs.version-check.outputs.version }}.vsix

      - name: Check Open VSX token availability
        id: check_token
        env:
          OVSX_TOKEN: ${{ secrets.OPEN_VSX_ACCESS_TOKEN }}
        run: |
          if [ -n "$OVSX_TOKEN" ]; then
            echo "has_token=true" >> $GITHUB_OUTPUT
          else
            echo "has_token=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.check_token.outputs.has_token == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Publish to Open VSX Registry
        id: publish
        if: steps.check_token.outputs.has_token == 'true'
        timeout-minutes: 10
        run: |
          set -e
          VSIX_FILE=$(find . -maxdepth 1 -name "*.vsix" -type f | head -n 1)

          if [ -z "$VSIX_FILE" ]; then
            echo "‚ùå VSIX file not found"
            exit 1
          fi

          echo "Publishing $VSIX_FILE to Open VSX Registry..."
          npx --yes ovsx publish "$VSIX_FILE" -p "$OVSX_PAT"
          echo "‚úÖ Published to Open VSX Registry"
        env:
          OVSX_PAT: ${{ secrets.OPEN_VSX_ACCESS_TOKEN }}
        continue-on-error: true

      - name: Report success
        if: steps.check_token.outputs.has_token == 'true' && steps.publish.outcome == 'success'
        run: |
          echo "‚úÖ Successfully published v${{ needs.version-check.outputs.version }} to Open VSX Registry"

      - name: Report Open VSX publish failure
        if: steps.check_token.outputs.has_token == 'true' && steps.publish.outcome == 'failure'
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Failed to publish v${{ needs.version-check.outputs.version }} to Open VSX Registry',
              body: [
                '## Open VSX Publish Failed',
                '',
                '**Version:** v${{ needs.version-check.outputs.version }}',
                '**Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}',
                '',
                'The automated Open VSX publish step failed. This may require manual intervention.',
                '',
                '### Next Steps:',
                '1. Check the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details',
                '2. Verify OPEN_VSX_ACCESS_TOKEN secret is valid and has proper permissions',
                '3. Download the VSIX from [workflow artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})',
                '4. Publish manually: `npx ovsx publish <vsix-file> -p <token>`',
                '5. Close this issue once resolved',
                '',
                '**Note:** The GitHub Release and git tag were created successfully.'
              ].join('\n'),
              labels: ['release', 'automation', 'openvsx', 'bug']
            });

      - name: Report token missing
        if: steps.check_token.outputs.has_token == 'false'
        run: |
          echo "‚ö†Ô∏è OPEN_VSX_ACCESS_TOKEN not configured, skipping Open VSX Registry publish"
          echo "To enable automatic publishing, add OPEN_VSX_ACCESS_TOKEN secret to repository settings"

  rollback:
    name: Rollback on Critical Failure
    runs-on: ubuntu-latest
    needs: [version-check, release, publish-vscode, publish-openvsx]
    if: |
      always() &&
      needs.version-check.outputs.changed == 'true' &&
      needs.release.outputs.release_created == 'true' &&
      (needs.publish-vscode.result == 'failure' || needs.publish-openvsx.result == 'failure')
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if both publishes failed
        id: check_failure
        run: |
          VSCODE_RESULT="${{ needs.publish-vscode.result }}"
          OPENVSX_RESULT="${{ needs.publish-openvsx.result }}"

          # Only rollback if BOTH marketplaces failed (catastrophic failure)
          if [ "$VSCODE_RESULT" == "failure" ] && [ "$OPENVSX_RESULT" == "failure" ]; then
            echo "Both marketplace publishes failed, considering rollback"
            echo "should_rollback=true" >> $GITHUB_OUTPUT
          else
            echo "At least one publish succeeded or was skipped, keeping release"
            echo "should_rollback=false" >> $GITHUB_OUTPUT
          fi

      - name: Create rollback issue (manual decision)
        if: steps.check_failure.outputs.should_rollback == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '‚ö†Ô∏è Release v${{ needs.version-check.outputs.version }} - Marketplace Publish Failed',
              body: [
                '## Critical: Both Marketplace Publishes Failed',
                '',
                '**Version:** v${{ needs.version-check.outputs.version }}',
                '**Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}',
                '',
                '### Status:',
                '- ‚úÖ GitHub Release created',
                '- ‚úÖ Git tag `v${{ needs.version-check.outputs.version }}` created',
                '- ‚ùå VS Code Marketplace publish failed',
                '- ‚ùå Open VSX Registry publish failed',
                '',
                '### Manual Decision Required:',
                '',
                '**Option 1: Retry Publishing (Recommended)**',
                '```bash',
                '# Download VSIX from workflow artifacts',
                '# Then manually publish:',
                'vsce publish --packagePath vscode-kafka-${{ needs.version-check.outputs.version }}.vsix',
                'npx ovsx publish vscode-kafka-${{ needs.version-check.outputs.version }}.vsix -p <token>',
                '```',
                '',
                '**Option 2: Rollback Release**',
                '```bash',
                'gh release delete v${{ needs.version-check.outputs.version }} --yes',
                'git push origin :refs/tags/v${{ needs.version-check.outputs.version }}',
                '```',
                '',
                '**Option 3: Keep Release as Pre-release**',
                '- Update the release to mark as pre-release',
                '- Fix the issue and re-run publish workflows',
                '',
                '### Next Steps:',
                '1. Review workflow logs for failure details',
                '2. Choose an option above',
                '3. Execute the chosen action',
                '4. Close this issue once resolved',
                '',
                '**Note:** Automated rollback was NOT performed to allow manual inspection.'
              ].join('\n'),
              labels: ['release', 'critical', 'requires-manual-action']
            });

  summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [version-check, security, build, release, publish-vscode, publish-openvsx]
    if: always() && needs.version-check.outputs.changed == 'true'
    timeout-minutes: 2

    steps:
      - name: Generate summary
        run: |
          echo "## üöÄ Release v${{ needs.version-check.outputs.version }} Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** v${{ needs.version-check.outputs.previous_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**New Version:** v${{ needs.version-check.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pipeline Status" >> $GITHUB_STEP_SUMMARY

          # Security
          if [ "${{ needs.security.result }}" == "success" ]; then
            echo "- ‚úÖ Security scan passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå Security scan failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Build
          if [ "${{ needs.build.result }}" == "success" ]; then
            echo "- ‚úÖ Build and package successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå Build and package failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Release
          if [ "${{ needs.release.result }}" == "success" ]; then
            echo "- ‚úÖ GitHub Release created" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå GitHub Release failed" >> $GITHUB_STEP_SUMMARY
          fi

          # VS Code Marketplace
          if [ "${{ needs.publish-vscode.result }}" == "success" ]; then
            echo "- ‚úÖ Published to VS Code Marketplace" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.publish-vscode.result }}" == "skipped" ]; then
            echo "- ‚è≠Ô∏è VS Code Marketplace publish skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå VS Code Marketplace publish failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Open VSX
          if [ "${{ needs.publish-openvsx.result }}" == "success" ]; then
            echo "- ‚úÖ Published to Open VSX Registry" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.publish-openvsx.result }}" == "skipped" ]; then
            echo "- ‚è≠Ô∏è Open VSX Registry publish skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå Open VSX Registry publish failed" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Links" >> $GITHUB_STEP_SUMMARY
          echo "- [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/v${{ needs.version-check.outputs.version }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

      - name: Check overall status
        run: |
          if [ "${{ needs.build.result }}" != "success" ] || \
             [ "${{ needs.release.result }}" != "success" ]; then
            echo "‚ùå Critical jobs failed"
            exit 1
          fi
          echo "‚úÖ Release pipeline completed"
